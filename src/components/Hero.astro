<section class="hero">
  <div class="container">
    <div class="content">
      <h1 class="name">
        Gustavo<br />
        <span class="gradient-text">Garozzo</span>
      </h1>

      <p class="role">
        Backend Ssr. &mdash; Node.js, NestJS y APIs escalables
      </p>

      <nav class="links">
        <a href="/cv.pdf" target="_blank" class="btn-primary">
          Descargar CV
        </a>
        <a href="mailto:gustavogarozzo@gmail.com" class="link-item">Email</a>
        <a href="https://github.com/gusgarozzo" target="_blank" class="link-item">GitHub</a>
        <a href="https://linkedin.com/in/gusgarozzo" target="_blank" class="link-item">LinkedIn</a>
      </nav>
    </div>

    <div class="hero-graphic">
      <div class="terminal-window">
        <div class="terminal-header">
          <div class="dot red"></div>
          <div class="dot yellow"></div>
          <div class="dot green"></div>
        </div>
        <div class="terminal-body" id="console-content">
<div class="line">
  <span class="prompt">›</span> whoami
</div>
<div class="line indent">
  Backend Engineer (Ssr.)
</div>

<div class="line">
  <span class="prompt">›</span> focus
</div>
<div class="line indent">
  Scalable APIs · Clean Architecture
</div>

<div class="line">
  <span class="prompt">›</span> stack
</div>
<div class="line indent">
  TypeScript · Node.js · NestJS · PostgreSQL
</div>

<div class="line">
  <span class="prompt">›</span> status
</div>
<div class="line indent">
  Currently open to opportunities
</div>

        </div>
      </div>
    </div>
  </div>
  
  <div class="decoration"></div>

  <style>
    .hero {
      padding: 4rem 0;
      position: relative;
      overflow: visible; /* Allow graphic to float freely if needed */
    }

    .container {
      display: grid;
      grid-template-columns: 1fr;
      gap: 3rem;
      align-items: center;
    }

    @media (min-width: 900px) {
      .container {
        grid-template-columns: 1.2fr 0.8fr;
      }
    }

    .name {
      font-size: 4rem;
      font-weight: 800;
      line-height: 1;
      margin-bottom: 1.5rem;
      letter-spacing: -0.03em;
    }
    
    @media (min-width: 768px) {
      .name {
         font-size: 5rem;
         margin-bottom: 2rem;
      }
    }

    .role {
      font-size: 1.25rem;
      color: var(--color-muted);
      margin-bottom: 2rem;
      font-weight: 500;
      max-width: 600px;
      line-height: 1.5;
    }
    
    @media (min-width: 768px) {
      .role {
        font-size: 1.5rem;
        margin-bottom: 2.5rem;
      }
    }

    .links {
      display: flex;
      gap: 1.5rem;
      align-items: center;
      flex-wrap: wrap;
    }

    .btn-primary {
      background: var(--gradient-primary);
      color: white;
      text-decoration: none;
      padding: 0.8rem 1.5rem;
      border-radius: var(--radius-md);
      font-weight: 600;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      box-shadow: var(--shadow-md);
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    .link-item {
      font-weight: 600;
      color: var(--color-text);
      position: relative;
      text-decoration: none;
    }

    .link-item::after {
      content: '';
      position: absolute;
      width: 100%;
      height: 2px;
      bottom: -4px;
      left: 0;
      background: var(--gradient-primary);
      transform: scaleX(0);
      transform-origin: right;
      transition: transform 0.3s ease;
    }

    .link-item:hover {
      color: var(--color-primary);
    }

    .link-item:hover::after {
      transform: scaleX(1);
      transform-origin: left;
    }
    
    /* Graphic Styles */
    .hero-graphic {
      display: none;
      justify-content: center;
      perspective: 1000px;
    }

    @media (min-width: 900px) {
      .hero-graphic {
        display: flex;
      }
    }

    .terminal-window {
      background: rgba(var(--color-background-off), 0.7); /* Fallback */
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 1.5rem;
      width: 100%;
      max-width: 400px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.3);
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.95rem;
      line-height: 1.8;
      transform: rotateY(-10deg) rotateX(5deg);
      transition: transform 0.3s ease;
      /* Removed float animation for sober look as requested */
    }
    
    :global([data-theme="light"]) .terminal-window {
       background: rgba(255, 255, 255, 0.7);
       border-color: rgba(0,0,0,0.1);
       box-shadow: 0 20px 40px rgba(0,0,0,0.1);
    }

    .terminal-window:hover {
      transform: rotateY(0) rotateX(0);
    }

    .terminal-header {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    .dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }

    .red { background: #ff5f56; }
    .yellow { background: #ffbd2e; }
    .green { background: #27c93f; }

    .terminal-body {
      color: #a9b7c6;
    }
    
    :global([data-theme="light"]) .terminal-body {
      color: #333;
    }

    .line {
      min-height: 1.8em;
      display: flex; /* Verify this doesn't break flow */
      align-items: center;
      flex-wrap: wrap; 
    }

    .cursor {
      display: inline-block;
      width: 0.6em;
      height: 1.2em;
      background-color: var(--color-primary);
      margin-left: 4px;
      animation: blink 1s step-end infinite;
      vertical-align: middle;
    }

    .prompt {
  color: var(--color-primary);
  margin-right: 0.5rem;
  font-weight: 600;
}


    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0; }
    }

    .indent { padding-left: 1.5rem; }
    .double-indent { padding-left: 3rem; }

    /* Syntax Highlighting */
    .keyword { color: #cc7832; font-weight: bold; }
    .variable { color: #a9b7c6; }
    .operator { color: #a9b7c6; }
    .bracket { color: #a9b7c6; }
    .string { color: #6a8759; }
    .key { color: #9876aa; }
    .comma { color: #cc7832; }

    /* Light Theme Syntax Overrides */
    :global([data-theme="light"]) .keyword { color: #0033b3; }
    :global([data-theme="light"]) .variable { color: #000; }
    :global([data-theme="light"]) .operator { color: #000; }
    :global([data-theme="light"]) .bracket { color: #000; }
    :global([data-theme="light"]) .string { color: #067d17; }
    :global([data-theme="light"]) .key { color: #660e7a; }
    :global([data-theme="light"]) .comma { color: #000; }

    .decoration {
      position: absolute;
      top: -50px;
      right: -50px;
      width: 200px;
      height: 200px;
      background: var(--gradient-primary);
      filter: blur(80px);
      opacity: 0.2;
      border-radius: 50%;
      z-index: -1;
      pointer-events: none;
    }

    @keyframes float {
      0% { transform: translateY(0px) rotateY(-10deg) rotateX(5deg); }
      50% { transform: translateY(-15px) rotateY(-10deg) rotateX(5deg); }
      100% { transform: translateY(0px) rotateY(-10deg) rotateX(5deg); }
    }
    
    /* Modify float for hover state to prevent conflict? 
       Actually, hover overrides transform, so animation might look jerky on hover.
       Let's pause animation on hover or wrap it. 
       For simplicity, let's keep it simple. */
       
  </style>
</section>

<script>
  function initTyping() {
    const container = document.getElementById('console-content');
    if (!container) return; // Guard clause

    // Capture the original content structure
    // We expect .line elements.
    const lines = Array.from(container.querySelectorAll('.line'));
    if (lines.length === 0) return;

    const fullContent = lines.map(line => line.cloneNode(true));
    
    // Clear the container initially
    container.innerHTML = '';
    
    // Create a persistent cursor element
    const cursor = document.createElement('span');
    cursor.className = 'cursor';

    // Type delay range (ms) - Slow and firm
    const typeDelay = { min: 30, max: 70 }; 

    const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));
    
    const randomDelay = () => Math.floor(Math.random() * (typeDelay.max - typeDelay.min + 1) + typeDelay.min);

    // Helper to type text content into an element
    // It creates text nodes char by char and inserts them before the cursor
    async function typeText(text, parentEl) {
      for (let char of text) {
        // Insert char before cursor
        const textNode = document.createTextNode(char);
        parentEl.insertBefore(textNode, cursor);
        await wait(randomDelay());
      }
    }

    // Interactive recursive function to process nodes
    async function typeNodesIterative(nodes, parentEl) {
        for (const node of nodes) {
            if (node.nodeType === Node.TEXT_NODE) {
                await typeText(node.textContent, parentEl);
            } else if (node.nodeType === Node.ELEMENT_NODE) {
                const newEl = document.createElement(node.tagName);
                newEl.className = node.className;
                if (node.getAttribute('style')) newEl.setAttribute('style', node.getAttribute('style'));
                
                // Insert element before cursor
                parentEl.insertBefore(newEl, cursor);
                
                // We do NOT move the cursor inside the new element.
                // We keep the cursor in the 'line' container or 'parentEl'.
                // But we need to type content *into* newEl.
                // To do that, we briefly move the cursor inside?
                
                // Better approach:
                // Append cursor to newEl to type inside it, then move it back out?
                // This simulates the cursor traveling into the syntax span.
                
                newEl.appendChild(cursor);
                await typeNodesIterative(Array.from(node.childNodes), newEl);
                
                // After typing inside newEl, move cursor back to parentEl, right after newEl
                parentEl.insertBefore(cursor, newEl.nextSibling);
            }
        }
    }

    async function typeLine(lineTemplate) {
        const lineEl = document.createElement('div');
        lineEl.className = lineTemplate.className;
        container.appendChild(lineEl);
        
        // Start cursor in the line
        lineEl.appendChild(cursor);
        
        await typeNodesIterative(Array.from(lineTemplate.childNodes), lineEl);
        
        // Line done.
        await wait(100); 
    }

    async function run() {
       await wait(1000); // Initial pause for dramatic effect
       
       for (const line of fullContent) {
           await typeLine(line);
           // After line is typed, we can leave cursor there or move to next line logic.
           // The next typeLine call will move the cursor to the new line div.
       }
       
       // Ensure cursor stays at the end
       // current location is fine.
    }
    
    run();
  }

  // Run on load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initTyping);
  } else {
    initTyping();
  }
</script>
